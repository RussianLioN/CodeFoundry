/**
 * Git Manager for OpenClaw Gateway
 *
 * Handles automatic Git operations for projects:
 * - Initialize repository
 * - Create commits
 * - Push to GitHub
 * - Create repositories via API
 */

// @ts-nocheck - TODO: Fix missing utils/logger import (TSFIX-003)

import { execSync, spawn } from 'child_process';
import { promises as fs } from 'fs';
import { join } from 'path';
import axios from 'axios';
import { logger } from './utils/logger';

export interface GitConfig {
  userName?: string;
  userEmail?: string;
  autoPush?: boolean;
  commitOnChange?: boolean;
}

export interface CommitOptions {
  type?: 'feat' | 'fix' | 'refactor' | 'docs' | 'test' | 'chore' | 'ai';
  message: string;
  files?: string[];
  body?: string;
  refs?: string;
}

export interface GitHubRepoOptions {
  name: string;
  description?: string;
  private?: boolean;
  autoInit?: boolean;
  gitignoreTemplate?: string;
}

export interface GitHubCreateResult {
  id: number;
  name: string;
  fullName: string;
  cloneUrl: string;
  sshUrl: string;
  htmlUrl: string;
}

export class GitManager {
  private config: GitConfig;

  constructor(config: GitConfig = {}) {
    this.config = {
      userName: config.userName || 'OpenClaw Bot',
      userEmail: config.userEmail || 'openclaw-bot@example.com',
      autoPush: config.autoPush ?? true,
      commitOnChange: config.commitOnChange ?? true,
    };
  }

  /**
   * Initialize Git repository in project directory
   */
  async init(projectPath: string): Promise<void> {
    logger.info(`Initializing Git repository: ${projectPath}`);

    try {
      // Check if already initialized
      const gitDir = join(projectPath, '.git');
      try {
        await fs.access(gitDir);
        logger.info('Git already initialized');
        return;
      } catch {
        // Not initialized, continue
      }

      // Initialize repository
      this.exec(projectPath, 'git init');

      // Configure user
      this.exec(projectPath, `git config user.name "${this.config.userName}"`);
      this.exec(projectPath, `git config user.email "${this.config.userEmail}"`);

      // Create .gitignore if not exists
      const gitignorePath = join(projectPath, '.gitignore');
      try {
        await fs.access(gitignorePath);
      } catch {
        await fs.writeFile(
          gitignorePath,
          this.getDefaultGitignore(),
          'utf-8'
        );
      }

      logger.info(`Git initialized: ${projectPath}`);
    } catch (error) {
      logger.error('Failed to initialize Git:', error);
      throw error;
    }
  }

  /**
   * Create initial commit for new project
   */
  async initialCommit(
    projectPath: string,
    metadata: { type: string; name: string }
  ): Promise<string> {
    logger.info(`Creating initial commit for: ${metadata.name}`);

    try {
      // Add all files
      this.exec(projectPath, 'git add -A');

      // Create commit message
      const message = `feat: Initial commit from OpenClaw

Project type: ${metadata.type}
Generated by: OpenClaw Gateway
Date: ${new Date().toISOString()}`;

      // Commit
      const hash = this.exec(projectPath, `git commit -m "${message}"`);
      logger.info(`Initial commit created: ${hash}`);

      return hash;
    } catch (error) {
      logger.error('Failed to create initial commit:', error);
      throw error;
    }
  }

  /**
   * Create a commit with changes
   */
  async commit(projectPath: string, options: CommitOptions): Promise<string> {
    logger.info(`Creating commit: ${options.message}`);

    try {
      // Check if there are changes
      const status = this.exec(projectPath, 'git status --porcelain');
      if (!status.trim()) {
        logger.info('No changes to commit');
        return '';
      }

      // Add files
      if (options.files && options.files.length > 0) {
        this.exec(projectPath, `git add ${options.files.join(' ')}`);
      } else {
        this.exec(projectPath, 'git add -A');
      }

      // Build commit message
      const commitMsg = this.buildCommitMessage(options);

      // Commit
      const hash = this.exec(projectPath, `git commit -m "${commitMsg}"`);
      logger.info(`Commit created: ${hash}`);

      // Auto push if enabled
      if (this.config.autoPush) {
        await this.push(projectPath);
      }

      return hash;
    } catch (error) {
      logger.error('Failed to create commit:', error);
      throw error;
    }
  }

  /**
   * Push changes to remote
   */
  async push(projectPath: string, branch: string = 'main', options: string[] = []): Promise<void> {
    logger.info(`Pushing to ${branch}...`);

    try {
      const opts = options.join(' ');
      this.exec(projectPath, `git push origin ${branch} ${opts}`);
      logger.info(`Pushed to ${branch}`);
    } catch (error) {
      logger.error('Failed to push:', error);
      throw error;
    }
  }

  /**
   * Pull changes from remote
   */
  async pull(projectPath: string, branch: string = 'main'): Promise<void> {
    logger.info(`Pulling from ${branch}...`);

    try {
      // Stash local changes first
      this.exec(projectPath, 'git stash save "Auto-stash before pull"');

      // Pull
      this.exec(projectPath, `git pull origin ${branch}`);

      // Try to reapply stashed changes
      try {
        this.exec(projectPath, 'git stash pop');
      } catch {
        logger.warn('Could not apply stashed changes, conflicts detected');
      }

      logger.info(`Pulled from ${branch}`);
    } catch (error) {
      logger.error('Failed to pull:', error);
      throw error;
    }
  }

  /**
   * Add remote repository
   */
  async addRemote(projectPath: string, url: string, name: string = 'origin'): Promise<void> {
    logger.info(`Adding remote ${name}: ${url}`);

    try {
      // Check if remote exists
      try {
        this.exec(projectPath, `git remote get-url ${name}`);
        // Update existing
        this.exec(projectPath, `git remote set-url ${name} ${url}`);
      } catch {
        // Add new
        this.exec(projectPath, `git remote add ${name} ${url}`);
      }

      logger.info(`Remote ${name} added`);
    } catch (error) {
      logger.error('Failed to add remote:', error);
      throw error;
    }
  }

  /**
   * Create GitHub repository via API
   */
  async createGitHubRepo(
    options: GitHubRepoOptions,
    githubToken: string
  ): Promise<GitHubCreateResult> {
    logger.info(`Creating GitHub repository: ${options.name}`);

    try {
      const response = await axios.post(
        'https://api.github.com/user/repos',
        {
          name: options.name,
          description: options.description || `OpenClaw project: ${options.name}`,
          private: options.private ?? true,
          auto_init: options.autoInit ?? false,
          gitignore_template: options.gitignoreTemplate,
        },
        {
          headers: {
            Authorization: `Bearer ${githubToken}`,
            Accept: 'application/vnd.github.v3+json',
          },
        }
      );

      const result: GitHubCreateResult = {
        id: response.data.id,
        name: response.data.name,
        fullName: response.data.full_name,
        cloneUrl: response.data.clone_url,
        sshUrl: response.data.ssh_url,
        htmlUrl: response.data.html_url,
      };

      logger.info(`GitHub repository created: ${result.htmlUrl}`);
      return result;
    } catch (error) {
      logger.error('Failed to create GitHub repository:', error);
      throw error;
    }
  }

  /**
   * Get repository status
   */
  async getStatus(projectPath: string): Promise<{
    branch: string;
    ahead: number;
    behind: number;
    staged: number;
    unstaged: number;
    untracked: number;
  }> {
    try {
      // Get branch name
      const branch = this.exec(projectPath, 'git rev-parse --abbrev-ref HEAD').trim();

      // Get ahead/behind
      let ahead = 0;
      let behind = 0;
      try {
        const aheadBehind = this.exec(projectPath, 'git rev-list --left-right --count origin/main...HEAD').trim();
        if (aheadBehind) {
          const [behindStr, aheadStr] = aheadBehind.split('\t');
          ahead = parseInt(aheadStr) || 0;
          behind = parseInt(behindStr) || 0;
        }
      } catch {
        // No remote or other error, ignore
      }

      // Get file counts
      const status = this.exec(projectPath, 'git status --porcelain').trim();
      let staged = 0;
      let unstaged = 0;
      let untracked = 0;

      if (status) {
        const lines = status.split('\n');
        for (const line of lines) {
          const index = line[0];
          const work = line[1];
          if (index === '?' || work === '?') untracked++;
          if (index !== ' ' && index !== '?') staged++;
          if (work !== ' ' && work !== '?') unstaged++;
        }
      }

      return {
        branch,
        ahead,
        behind,
        staged,
        unstaged,
        untracked,
      };
    } catch (error) {
      logger.error('Failed to get status:', error);
      throw error;
    }
  }

  /**
   * Execute git command in directory
   */
  private exec(cwd: string, command: string): string {
    try {
      return execSync(command, { cwd, encoding: 'utf-8' });
    } catch (error) {
      throw new Error(`Git command failed: ${command}`);
    }
  }

  /**
   * Build commit message from options
   */
  private buildCommitMessage(options: CommitOptions): string {
    const type = options.type || 'chore';
    let message = `${type}: ${options.message}`;

    if (options.body) {
      message += `\n\n${options.body}`;
    }

    if (options.refs) {
      message += `\n\nRefs: ${options.refs}`;
    }

    // Escape double quotes
    return message.replace(/"/g, '\\"');
  }

  /**
   * Get default .gitignore content
   */
  private getDefaultGitignore(): string {
    return `# Dependencies
node_modules/
__pycache__/
*.py[cod]
*$py.class
venv/
env/
.venv

# Build outputs
dist/
build/
*.egg-info/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
.env.*.local

# Logs
logs/
*.log
npm-debug.log*

# Testing
.coverage
htmlcov/
.pytest_cache/

# Temporary files
tmp/
temp/
*.tmp

# OpenClaw specific
.claude/local/
`;
  }
}

// Singleton instance
let gitManager: GitManager;

export function getGitManager(): GitManager {
  if (!gitManager) {
    gitManager = new GitManager({
      userName: process.env.GIT_AUTHOR_NAME || 'OpenClaw Bot',
      userEmail: process.env.GIT_AUTHOR_EMAIL || 'openclaw-bot@example.com',
      autoPush: process.env.GIT_AUTO_PUSH === 'true',
      commitOnChange: process.env.GIT_COMMIT_ON_CHANGE === 'true',
    });
  }
  return gitManager;
}

export default GitManager;
