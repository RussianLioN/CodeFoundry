"use strict";
/**
 * Git Manager for OpenClaw Gateway
 *
 * Handles automatic Git operations for projects:
 * - Initialize repository
 * - Create commits
 * - Push to GitHub
 * - Create repositories via API
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitManager = void 0;
exports.getGitManager = getGitManager;
// @ts-nocheck - TODO: Fix missing utils/logger import (TSFIX-003)
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const axios_1 = __importDefault(require("axios"));
const logger_1 = require("./utils/logger");
class GitManager {
    config;
    constructor(config = {}) {
        this.config = {
            userName: config.userName || 'OpenClaw Bot',
            userEmail: config.userEmail || 'openclaw-bot@example.com',
            autoPush: config.autoPush ?? true,
            commitOnChange: config.commitOnChange ?? true,
        };
    }
    /**
     * Initialize Git repository in project directory
     */
    async init(projectPath) {
        logger_1.logger.info(`Initializing Git repository: ${projectPath}`);
        try {
            // Check if already initialized
            const gitDir = (0, path_1.join)(projectPath, '.git');
            try {
                await fs_1.promises.access(gitDir);
                logger_1.logger.info('Git already initialized');
                return;
            }
            catch {
                // Not initialized, continue
            }
            // Initialize repository
            this.exec(projectPath, 'git init');
            // Configure user
            this.exec(projectPath, `git config user.name "${this.config.userName}"`);
            this.exec(projectPath, `git config user.email "${this.config.userEmail}"`);
            // Create .gitignore if not exists
            const gitignorePath = (0, path_1.join)(projectPath, '.gitignore');
            try {
                await fs_1.promises.access(gitignorePath);
            }
            catch {
                await fs_1.promises.writeFile(gitignorePath, this.getDefaultGitignore(), 'utf-8');
            }
            logger_1.logger.info(`Git initialized: ${projectPath}`);
        }
        catch (error) {
            logger_1.logger.error('Failed to initialize Git:', error);
            throw error;
        }
    }
    /**
     * Create initial commit for new project
     */
    async initialCommit(projectPath, metadata) {
        logger_1.logger.info(`Creating initial commit for: ${metadata.name}`);
        try {
            // Add all files
            this.exec(projectPath, 'git add -A');
            // Create commit message
            const message = `feat: Initial commit from OpenClaw

Project type: ${metadata.type}
Generated by: OpenClaw Gateway
Date: ${new Date().toISOString()}`;
            // Commit
            const hash = this.exec(projectPath, `git commit -m "${message}"`);
            logger_1.logger.info(`Initial commit created: ${hash}`);
            return hash;
        }
        catch (error) {
            logger_1.logger.error('Failed to create initial commit:', error);
            throw error;
        }
    }
    /**
     * Create a commit with changes
     */
    async commit(projectPath, options) {
        logger_1.logger.info(`Creating commit: ${options.message}`);
        try {
            // Check if there are changes
            const status = this.exec(projectPath, 'git status --porcelain');
            if (!status.trim()) {
                logger_1.logger.info('No changes to commit');
                return '';
            }
            // Add files
            if (options.files && options.files.length > 0) {
                this.exec(projectPath, `git add ${options.files.join(' ')}`);
            }
            else {
                this.exec(projectPath, 'git add -A');
            }
            // Build commit message
            const commitMsg = this.buildCommitMessage(options);
            // Commit
            const hash = this.exec(projectPath, `git commit -m "${commitMsg}"`);
            logger_1.logger.info(`Commit created: ${hash}`);
            // Auto push if enabled
            if (this.config.autoPush) {
                await this.push(projectPath);
            }
            return hash;
        }
        catch (error) {
            logger_1.logger.error('Failed to create commit:', error);
            throw error;
        }
    }
    /**
     * Push changes to remote
     */
    async push(projectPath, branch = 'main', options = []) {
        logger_1.logger.info(`Pushing to ${branch}...`);
        try {
            const opts = options.join(' ');
            this.exec(projectPath, `git push origin ${branch} ${opts}`);
            logger_1.logger.info(`Pushed to ${branch}`);
        }
        catch (error) {
            logger_1.logger.error('Failed to push:', error);
            throw error;
        }
    }
    /**
     * Pull changes from remote
     */
    async pull(projectPath, branch = 'main') {
        logger_1.logger.info(`Pulling from ${branch}...`);
        try {
            // Stash local changes first
            this.exec(projectPath, 'git stash save "Auto-stash before pull"');
            // Pull
            this.exec(projectPath, `git pull origin ${branch}`);
            // Try to reapply stashed changes
            try {
                this.exec(projectPath, 'git stash pop');
            }
            catch {
                logger_1.logger.warn('Could not apply stashed changes, conflicts detected');
            }
            logger_1.logger.info(`Pulled from ${branch}`);
        }
        catch (error) {
            logger_1.logger.error('Failed to pull:', error);
            throw error;
        }
    }
    /**
     * Add remote repository
     */
    async addRemote(projectPath, url, name = 'origin') {
        logger_1.logger.info(`Adding remote ${name}: ${url}`);
        try {
            // Check if remote exists
            try {
                this.exec(projectPath, `git remote get-url ${name}`);
                // Update existing
                this.exec(projectPath, `git remote set-url ${name} ${url}`);
            }
            catch {
                // Add new
                this.exec(projectPath, `git remote add ${name} ${url}`);
            }
            logger_1.logger.info(`Remote ${name} added`);
        }
        catch (error) {
            logger_1.logger.error('Failed to add remote:', error);
            throw error;
        }
    }
    /**
     * Create GitHub repository via API
     */
    async createGitHubRepo(options, githubToken) {
        logger_1.logger.info(`Creating GitHub repository: ${options.name}`);
        try {
            const response = await axios_1.default.post('https://api.github.com/user/repos', {
                name: options.name,
                description: options.description || `OpenClaw project: ${options.name}`,
                private: options.private ?? true,
                auto_init: options.autoInit ?? false,
                gitignore_template: options.gitignoreTemplate,
            }, {
                headers: {
                    Authorization: `Bearer ${githubToken}`,
                    Accept: 'application/vnd.github.v3+json',
                },
            });
            const result = {
                id: response.data.id,
                name: response.data.name,
                fullName: response.data.full_name,
                cloneUrl: response.data.clone_url,
                sshUrl: response.data.ssh_url,
                htmlUrl: response.data.html_url,
            };
            logger_1.logger.info(`GitHub repository created: ${result.htmlUrl}`);
            return result;
        }
        catch (error) {
            logger_1.logger.error('Failed to create GitHub repository:', error);
            throw error;
        }
    }
    /**
     * Get repository status
     */
    async getStatus(projectPath) {
        try {
            // Get branch name
            const branch = this.exec(projectPath, 'git rev-parse --abbrev-ref HEAD').trim();
            // Get ahead/behind
            let ahead = 0;
            let behind = 0;
            try {
                const aheadBehind = this.exec(projectPath, 'git rev-list --left-right --count origin/main...HEAD').trim();
                if (aheadBehind) {
                    const [behindStr, aheadStr] = aheadBehind.split('\t');
                    ahead = parseInt(aheadStr) || 0;
                    behind = parseInt(behindStr) || 0;
                }
            }
            catch {
                // No remote or other error, ignore
            }
            // Get file counts
            const status = this.exec(projectPath, 'git status --porcelain').trim();
            let staged = 0;
            let unstaged = 0;
            let untracked = 0;
            if (status) {
                const lines = status.split('\n');
                for (const line of lines) {
                    const index = line[0];
                    const work = line[1];
                    if (index === '?' || work === '?')
                        untracked++;
                    if (index !== ' ' && index !== '?')
                        staged++;
                    if (work !== ' ' && work !== '?')
                        unstaged++;
                }
            }
            return {
                branch,
                ahead,
                behind,
                staged,
                unstaged,
                untracked,
            };
        }
        catch (error) {
            logger_1.logger.error('Failed to get status:', error);
            throw error;
        }
    }
    /**
     * Execute git command in directory
     */
    exec(cwd, command) {
        try {
            return (0, child_process_1.execSync)(command, { cwd, encoding: 'utf-8' });
        }
        catch (error) {
            throw new Error(`Git command failed: ${command}`);
        }
    }
    /**
     * Build commit message from options
     */
    buildCommitMessage(options) {
        const type = options.type || 'chore';
        let message = `${type}: ${options.message}`;
        if (options.body) {
            message += `\n\n${options.body}`;
        }
        if (options.refs) {
            message += `\n\nRefs: ${options.refs}`;
        }
        // Escape double quotes
        return message.replace(/"/g, '\\"');
    }
    /**
     * Get default .gitignore content
     */
    getDefaultGitignore() {
        return `# Dependencies
node_modules/
__pycache__/
*.py[cod]
*$py.class
venv/
env/
.venv

# Build outputs
dist/
build/
*.egg-info/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
.env.*.local

# Logs
logs/
*.log
npm-debug.log*

# Testing
.coverage
htmlcov/
.pytest_cache/

# Temporary files
tmp/
temp/
*.tmp

# OpenClaw specific
.claude/local/
`;
    }
}
exports.GitManager = GitManager;
// Singleton instance
let gitManager;
function getGitManager() {
    if (!gitManager) {
        gitManager = new GitManager({
            userName: process.env.GIT_AUTHOR_NAME || 'OpenClaw Bot',
            userEmail: process.env.GIT_AUTHOR_EMAIL || 'openclaw-bot@example.com',
            autoPush: process.env.GIT_AUTO_PUSH === 'true',
            commitOnChange: process.env.GIT_COMMIT_ON_CHANGE === 'true',
        });
    }
    return gitManager;
}
exports.default = GitManager;
//# sourceMappingURL=git-manager.js.map